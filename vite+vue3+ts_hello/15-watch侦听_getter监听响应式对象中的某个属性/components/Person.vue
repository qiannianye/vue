<template>
    <div class="person">
        <h2>情况四：监视【reactive】创建的对象的某个属性（或者叫【getter】方法返回的数据，即监视一个函数的返回值）</h2>
        <h3>姓名：{{ person.name }}  年龄：{{ person.age }}</h3>
        <!-- car是数组时 -->
        <li v-for="c in person.car" :key="c.id">{{ c.name }}</li>
        <!-- car是对象时 -->
        <!-- <h3>{{ person.car.c1 }}</h3> -->
        <button @click="changeName">修改名字</button>
        <button @click="changeCar">修改车</button>
    </div>
</template>

<script lang="ts" setup>
   import { reactive, watch } from 'vue'
   let person = reactive({
    name: '张三',
    age: 18,
    car: [{id: 1,name: '奔驰',price: 100},{id: 2,name: '宝马',price: 200}], //car是数组
    // car: {
    //     c1: '奔驰',
    //     c2: '宝马'
    // }, //car是对象
   })
   function changeName() {
    person.name += '#'
   }
   function changeCar() {
    //=================
    // 情况-：car是数组时，监听源是直接监听【person.car】时，且未开启【深度监视】的更改。
    // 更改car数组中的某一项的某个属性的时候，可以正确监听到改变，且新旧值一样（忽略初次立即监听时旧值是undefined的情况，更改后新旧值一样），再次更改不再调回调函数，因为再次点击按钮更改的值还是‘大众’，值没变，所以监听到值没变，所以不调回调函数。
    // person.car[0].name = '大众'

    // 更改car数组中的某一项的时候，可以正确监听到改变，且新旧值一样（忽略初次立即监听时旧值是undefined的情况，更改后新旧值一样），且每次点击按钮更改，回调函数就执行一次，且新旧值一样，因为监听的是地址值，地址值发生了改变，所以监听到改变了。
    // person.car[0] = {id: 3, name: '哈佛', price:40}

    // 更改整个car数组时，虽然person中的car值变了，页面上也正确展示了改变后的值，但是watch里却没能监听到值的改变，因为watch监听的是person里car的值，而不是地址值，所以即使地址值发生了改变，也监听不到。
    // person.car = [{id: 99, name: '劳斯莱斯', price: 1000}]

    //==================
    // 情况二：car是对象时，监听源是直接监听【person.car】时，且未开启【深度监视】的更改。
    // 更改car中的某一个属性的时候，可以正确监听到改变，且新旧值一样（忽略初次立即监听时旧值是undefined的情况，更改后新旧值一样），再次更改不再调回调函数，因为再次点击按钮更改的值还是‘大众’，值没变，所以监听到值没变，所以不调回调函数。
    // person.car.c1 = '大众'

    // 更改整个car对象时，虽然person中的car值变了，页面上也正确展示了改变后的值，但是watch里却没能监听到值的改变，因为watch监听的是person里car的值，而不是地址值，所以即使地址值发生了改变，也监听不到。（同数组一样）
    // person.car = {c1: '法拉利', c2: 'ddd'} //这里因为是ts，所以car的隐式类型是{c1:string, c2:string}，所以整个对象更改时必须是这个类型。

    //===================
    // 情况三：car是对象时，监听源是【getter】返回的数据时(必须得开启深度监视，才能监听到变化？），且开启深度监视的更改。
    // 更改car中的某个属性时，可以正确监听到改变，且新旧值一样（忽略初次立即监听时旧值是undefined的情况，更改后新旧值一样），再次更改不再调回调函数，因为再次点击按钮更改的值还是‘大众’，值没变，所以监听到值没变，所以不调回调函数。
    // person.car.c1 = '大众' //改变[响应式对象]中某个【对象属性】中的某个值，【必须】【开启】【深度监视】，才能监听到变化。

    // 更改整个car对象时，能正确监听到改变，第一次点击按钮更改后，新旧值不一样，后面每次点击按钮更改，回调函数就执行一次，且新旧值一样，因为监听的是地址值，地址值发生了改变，所以监听到改变了，所以回调函数就执行。
    // person.car = {c1: '法拉利', c2: '劳斯莱斯'} //整个改变[响应式对象]中的某个【对象属性】时，【不开启深度监视，也可以监听到变化】。

    //===================
    // 情况四：car是数组时，监听源是【getter】返回的数据时(必须得开启深度监视，才能监听到变化？），且开启深度监视的更改。
    // 更改car数组中的某一项的某个属性的时候，可以正确监听到改变，且新旧值一样（忽略初次立即监听时旧值是undefined的情况，更改后新旧值一样），再次更改不再调回调函数，因为再次点击按钮更改的值还是‘大众’，值没变，所以监听到值没变，所以不调回调函数。
    // person.car[0].name = '大众' //改变[响应式对象]中某个【对象属性】中的某个值，【必须】【开启】【深度监视】，才能监听到变化。

    // 更改car数组中的某一项的时候，可以正确监听到改变，且新旧值一样（忽略初次立即监听时旧值是undefined的情况，更改后新旧值一样），且每次点击按钮更改，回调函数就执行一次，且新旧值一样，因为监听的是地址值，地址值发生了改变，所以监听到改变了。
    // person.car[0] = {id: 3, name: '哈佛', price:40} //改变[响应式对象]中某个【对象属性】中的某个值，【必须】【开启】【深度监视】，才能监听到变化。

    // 更改整个car数组时，能正确监听到改变，第一次点击按钮更改后，新旧值不一样，后面每次点击按钮更改，回调函数就执行一次，且新旧值一样，因为监听的是地址值，地址值发生了改变，所以监听到改变了，所以回调函数就执行。（同对象一样）
    person.car = [{id: 99, name: '劳斯莱斯', price: 1000}] //整个改变[响应式对象]中的某个【对象属性】时，【不开启深度监视，也可以监听到变化】。

    //===================
    // 综上所述，在监听【响应式对象】中的某个属性的时候，为了不出错，
    // 1:必须开启深度监视，deep:true。
    // 2:必须使用【getter】作为监视源。
   }
   // 监听person对象中的【name（string）】属性
   // 下面这种写法是错误的，不可以直接监听响应式对象的某个【一般类型】的属性
//    watch(person.name, (name => {
//     console.log('@@名字改变了', name)
//    }))

    //若想监听响应式对象的某个【一般类型】的属性，可以使用getter方法
    watch(() => person.name, (newValue, oldValue) => {
        console.log('@@名字发生改变了：', newValue, oldValue)
    }, {immediate: true})

    // 监听person对象中的【car（数组）】/【car（对象）】属性.
    // 监听源直接是person.car的监听，这种写法有时候也能正确监听到值的变化，但监听的是person.car的值，而不是地址值，所以当地址值发生更改的时候，不能正确监听，所以这种写法极其不推荐。了解即可，开发中勿用！
    // watch(person.car, (newValue, oldValue) => {
    //     console.log('@@车发生改变了：', newValue, oldValue)
    // }, {immediate: true})

    // 监听person对象中的【car（数组）】/【car（对象）】属性. 
    // 使用【getter】作为监听源，推荐使用。注意：当【getter】返回的是对象中某个对象属性时，即监听对象中的对象属性时，一定要【开启】【深度监视】，否则监视不到变化。
    watch(() => person.car, (newValue, oldValue) => {
        console.log('@@车发生改变了：', newValue, oldValue)
    }, {immediate: true, deep: true})
   
</script>

<style scoped>
    /* scoped: 局部样式标记，代表style里的样式只在本文件内生效，与其他文件里的同名样式互不干扰。 */
    .person {
        background-color: skyblue;
        border: 1px solid blueviolet;
        margin: 20px;
        padding: 20px;
    }
    button {
        margin-right: 10px;
    }
</style>